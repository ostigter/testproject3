DESIGN
======


Standards
---------

SEMI E05 SECS-II
SEMI E30 GEM
SEMI E37 HSMS


Message (de)serialization
-------------------------

1111 1100 0xfc // Format Code mask
0000 0011 0x03 // Length mask

0000 0001 0x01 // format List (L), 1 length byte
0000 1010 0x0a // 10 items

0010 0001 0x21 // format = Bytes (B), 2 length bytes
0000 0001 0x01
0000 0011 0x03 // 1 * 256 + 3 = 259 bytes

0010 0101 0x25 // format = Boolean (TF), 1 length byte
0000 0001 0x01 // True

0100 0001 0x41 // format = 7-bit ASCII (A), 1 length byte 
0001 0100 0x14 // 20 characters

0110 0101 0x65 // format = 1-byte signed integer (I1), 1 length byte
0000 0011 0x03 // 3 / 1 = 3 signed 1-byte integer

0110 1001 0x69 // format = 2-byte signed integer (I2), 1 length byte
0000 0110 0x06 // 6 / 2 = 3 signed 2-byte integer

0111 0001 0x71 // format = 4-byte signed integer (I4), 1 length byte
0000 1100 0x0c // 12 / 4 = 3 signed 2-byte integer

0110 0001 0x61 // format = 8-byte signed integer (I4), 1 length byte
0001 1000 0x18 // 24 / 8 = 3 signed 8-byte integer

1010 0101 0xa5 // format = 1-byte unsigned integer (U1), 1 length byte
0000 0010 0x02 // 2 / 1 = 2 unsigned 2-byte integers

1010 1001 0xa9 // format = 2-byte unsigned integer (U2), 1 length byte
0000 0110 0x06 // 6 / 2 = 3 unsigned 2-byte integers

1011 0001 0xb1 // format = 4-byte unsigned integer (U4), 1 length byte
0000 0100 0x04 // 4 / 4 = 1 unsigned 4-byte integer

1010 0001 0xa1 // format = 8-byte unsigned integer (U8), 1 length byte
0000 0100 0x04 // 16 / 8 = 2 unsigned 8-byte integer

1001 0001 0x91 // format = 4-byte single-precision floating-point (F4), 1 length byte
0000 0100 0x04 // 4 / 4 = 1 single-precision floating-point number

1000 0001 0x81 // format = 8-byte double-precision floating-point (F8), 1 length byte
0001 0000 0x10 // 16 / 8 = 2 double-precision floating-point numbers

L {
    B {01 7f 80 ff}
    TF {True}
    A {'abc'}
    U2 {259}
}

0x01 (format L, 1 length byte)
0x04 (length 4 items)
0x21 (format B, 1 length byte)
0x04 (length 4 bytes)
0x01
0x7f
0x80
0xff

0x41 (format A, 1 length byte)
0x03 (length 3 characters)
0x61 ('a')
0x62 ('b')
0x63 ('c')

L {
    A {'XXX'}
    A {'YYY'}
}

01 03 41 03 XX XX XX 41 04 YY YY YY YY

01 // format: L
03 // length: 3 items
41 // format: A
03 // length: 3 characters
XX
XX
XX
41 // format: A
04 // length: 4 characters
YY
YY
YY
YY

L {
    A {'XXX'}
    L {
        A {'YYY'}
        A {'ZZZ'}
    }
}

01 02 41 03 XX XX XX 01 02 41 03 YY YY YY 41 03 ZZ ZZ ZZ

L {
    L {
        B {11 12 13}
        B {21 22 23}
    }
    L {
        B {31 32 33}
        B {41 42 43}
    }
}

01 02 01 02 21 03 11 12 13 21 03 21 22 23 21 03 31 32 33 21 03 41 42 43


API design
==========

public interface SecsMessage {
    int getStream();
    int getFunction();
    int getSessionId();
    void setSessionId(int sessionId);
    long getTransactionId();
    void setTransactionId(long transactionId);
    void parseData<Data<?> data) throws SecsParseException;
    Data<?> getData() throws SecsParseException;
}

public interface SecsPrimaryMessage extends SecsMessage {
    boolean withReply();
    SecsMessage handle() throws SecsExcception;
}

public interface SecsReplyMessage extends SecsMessage {
    SecsPrimaryMessage getPrimaryMessage();
    void setPrimaryMessage(SecsPrimaryMessage primaryMessage);
}


API usage example
=================

Active equipment:

SecsEquipment equipment = new SecsEquipment();
equipment.setConnectMode(ConnectMode.ACTIVE);
equipment.setHost(HOST);
equipment.setPort(PORT);
equipment.setT3(10);
equipment.setTraceDir("D:/SECS/log");
equipment.setEnabled(true);

SecsMessage s99f1 = new S99F1();
s99f1.setName("Mr. Smith");
SecsMessage reply = equipment.sendAndWait(s99f1);
if (reply instanceof S99F2) {
    SecsMessage s99f2 = (S99F2) reply;
    int ackCode = s99f2.getAckCode();
    String greeting = s99f2.getGreeting();
    // ...
} else {
    // Unexpected message type, e.g. S9F7 (Bad data).
    System.err.println("Received " + reply + " instead of S99F2");
}

Passive equipment:

SecsEquipment equipment = new SecsEquipment();
equipment.setConnectMode(ConnectMode.PASSIVE);
equipment.setPort(PORT);
equipment.addMessageType(S99F1.class);
equipment.setEnabled(true);

public class S99F1 extends SecsPrimaryMessage {

    private String name;
    
    @Override
    public int getStream() {
        return 99;
    }
    
    @Override
    public int getFunction() {
        return 1;
    }
    
    @Override
    public boolean withReply() {
        return true;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    @Override
    public void parseData(Data<?> data) throws ParseException {
        // ...
    }
    
    @Override
    public Data<?> getData() throws ParseException {
        Data<?> data = null;
        // ...
        return data;
    }
    
    @Override
    public SecsMessage handle() throws SecsException {
        String name = getName();
        S99F2 s99f2 = new S99F2();
        s99f2.setPrimaryMessage(this);
        s99f2.setGreeting(String.format("Hello, %s!", name));
        return s99f2;
    }
}

public class S99F2 implements SecsReplyMessage {

    private int grAck;
    private String greeting;
    
    @Override
    public int getStream() {
        return 99;
    }
    
    @Override
    public int getFunction() {
        return 2;
    }
    
    @Override
    public boolean withReply() {
        return false;
    }
    
    public int getGrAck() {
        return grAck;
    }
    
    public void setGrAck(int grAck) {
        this.grAck = grAck;
    }
    
    public String getGreeting() {
        return greeting;
    }
    
    public void setGreeting(String greeting) {
        this.greeting = greeting;
    }
    
    @Override
    public void parseData(Data<?> data) throws ParseException {
        // ...
    }
    
    @Override
    public Data<?> getData() throws ParseException {
        Data<?> data = null;
        // ...
        return data;
    }
    
    @Override
    public void setPrimaryMessage(SecsPrimaryMessage primaryMessage) {
        if (primaryMessage instanceof S99F1) {
            this.primaryMessage = primaryMessage;
        } else {
            throw new IllegalArgumentException("Invalid primary message for S99F2: " + primaryMessage);
        }
    }
}

public interface SecsMessageHandler<P extends SecsPrimaryMessage, R extends SecsReplyMessage> {

    R handle(P primaryMessage) throws SecsException;
}

public class S99F1Handler implements SecsMessageHandler<S99F1, S99F2> {

    public S99F2 handle(S99F1 s99f1) throws SecsException {
        String name = s99f1.getName();
        if (name.isEmpty()) {
            throw new SecsParseException("Empty NAME");
        }
        String greeting = new String("Hello, %s!", name); 
        S99F2 s99f2 = new S99F2();
        s99f2.setGreeting(greeting);
        return s99f2;    
    }
}
